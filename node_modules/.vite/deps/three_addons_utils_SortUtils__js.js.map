{
  "version": 3,
  "sources": ["../../three/examples/jsm/utils/SortUtils.js"],
  "sourcesContent": ["// Hybrid radix sort from\n// - https://gist.github.com/sciecode/93ed864dd77c5c8803c6a86698d68dab\n// - https://github.com/mrdoob/three.js/pull/27202#issuecomment-1817640271\n//\n// expects unsigned 32b integer values\n\nconst POWER = 3;\nconst BIT_MAX = 32;\nconst BIN_BITS = 1 << POWER;\nconst BIN_SIZE = 1 << BIN_BITS;\nconst BIN_MAX = BIN_SIZE - 1;\nconst ITERATIONS = BIT_MAX / BIN_BITS;\n\nconst bins = new Array( ITERATIONS );\nconst bins_buffer = new ArrayBuffer( ( ITERATIONS + 1 ) * BIN_SIZE * 4 );\n\nlet c = 0;\nfor ( let i = 0; i < ( ITERATIONS + 1 ); i ++ ) {\n\n\tbins[ i ] = new Uint32Array( bins_buffer, c, BIN_SIZE );\n\tc += BIN_SIZE * 4;\n\n}\n\nconst defaultGet = ( el ) => el;\n\nexport const radixSort = ( arr, opt ) => {\n\n\tconst len = arr.length;\n\n\tconst options = opt || {};\n\tconst aux = options.aux || new arr.constructor( len );\n\tconst get = options.get || defaultGet;\n\n\tconst data = [ arr, aux ];\n\n\tlet compare, accumulate, recurse;\n\n\tif ( options.reversed ) {\n\n\t\tcompare = ( a, b ) => a < b;\n\t\taccumulate = ( bin ) => {\n\n\t\t\tfor ( let j = BIN_SIZE - 2; j >= 0; j -- )\n\t\t\t\tbin[ j ] += bin[ j + 1 ];\n\n\t\t};\n\n\t\trecurse = ( cache, depth, start ) => {\n\n\t\t\tlet prev = 0;\n\t\t\tfor ( let j = BIN_MAX; j >= 0; j -- ) {\n\n\t\t\t\tconst cur = cache[ j ], diff = cur - prev;\n\t\t\t\tif ( diff != 0 ) {\n\n\t\t\t\t\tif ( diff > 32 )\n\t\t\t\t\t\tradixSortBlock( depth + 1, start + prev, diff );\n\t\t\t\t\telse\n\t\t\t\t\t\tinsertionSortBlock( depth + 1, start + prev, diff );\n\t\t\t\t\tprev = cur;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t} else {\n\n\t\tcompare = ( a, b ) => a > b;\n\t\taccumulate = ( bin ) => {\n\n\t\t\tfor ( let j = 1; j < BIN_SIZE; j ++ )\n\t\t\t\tbin[ j ] += bin[ j - 1 ];\n\n\t\t};\n\n\t\trecurse = ( cache, depth, start ) => {\n\n\t\t\tlet prev = 0;\n\t\t\tfor ( let j = 0; j < BIN_SIZE; j ++ ) {\n\n\t\t\t\tconst cur = cache[ j ], diff = cur - prev;\n\t\t\t\tif ( diff != 0 ) {\n\n\t\t\t\t\tif ( diff > 32 )\n\t\t\t\t\t\tradixSortBlock( depth + 1, start + prev, diff );\n\t\t\t\t\telse\n\t\t\t\t\t\tinsertionSortBlock( depth + 1, start + prev, diff );\n\t\t\t\t\tprev = cur;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tconst insertionSortBlock = ( depth, start, len ) => {\n\n\t\tconst a = data[ depth & 1 ];\n\t\tconst b = data[ ( depth + 1 ) & 1 ];\n\n\t\tfor ( let j = start + 1; j < start + len; j ++ ) {\n\n\t\t\tconst p = a[ j ], t = get( p ) >>> 0;\n\t\t\tlet i = j;\n\t\t\twhile ( i > start ) {\n\n\t\t\t\tif ( compare( get( a[ i - 1 ] ) >>> 0, t ) )\n\t\t\t\t\ta[ i ] = a[ -- i ];\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\ta[ i ] = p;\n\n\t\t}\n\n\t\tif ( ( depth & 1 ) == 1 ) {\n\n\t\t\tfor ( let i = start; i < start + len; i ++ )\n\t\t\t\tb[ i ] = a[ i ];\n\n\t\t}\n\n\t};\n\n\tconst radixSortBlock = ( depth, start, len ) => {\n\n\t\tconst a = data[ depth & 1 ];\n\t\tconst b = data[ ( depth + 1 ) & 1 ];\n\n\t\tconst shift = ( 3 - depth ) << POWER;\n\t\tconst end = start + len;\n\n\t\tconst cache = bins[ depth ];\n\t\tconst bin = bins[ depth + 1 ];\n\n\t\tbin.fill( 0 );\n\n\t\tfor ( let j = start; j < end; j ++ )\n\t\t\tbin[ ( get( a[ j ] ) >>> shift ) & BIN_MAX ] ++;\n\n\t\taccumulate( bin );\n\n\t\tcache.set( bin );\n\n\t\tfor ( let j = end - 1; j >= start; j -- )\n\t\t\tb[ start + -- bin[ ( get( a[ j ] ) >>> shift ) & BIN_MAX ] ] = a[ j ];\n\n\t\tif ( depth == ITERATIONS - 1 ) return;\n\n\t\trecurse( cache, depth, start );\n\n\t};\n\n\tradixSortBlock( 0, 0, len );\n\n};\n"],
  "mappings": "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",
  "names": ["len"]
}
